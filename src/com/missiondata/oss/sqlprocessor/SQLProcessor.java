/*
 * SQLProcessor - a facade for the JDBC API
 * Copyright (C) 2001-2003 Mission Data
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package com.missiondata.oss.sqlprocessor;


import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * sqlprocessor is a facade for parts of the JDBC API.  It hides much of the complexity
 * and danger of dealing directly with the JDBC API.  The best way to show this is with
 * an example:
 * Without sqlprocessor
 * <pre>
 * PreparedStatement statement = null;
 * try
 * {
 *   statement = user.getConnection().prepareStatement("select id from foo where name = ? and state = ?");
 *   statement.setString( 1, "bar" );
 *   statement.setString( 2, "paid" );
 *   ResultSet resultSet = statement.executeQuery();
 *   while( resultSet.next() )
 *   {
 *     processId( resultSet.getString( "id" );
 *   }
 * }
 * catch( SQLException e )
 * {
 *   throw SystemException( e );
 * }
 * finally
 * {
 *   DataUtil.closeStatement( statement );
 * }
 * </pre>
 *
 * With sqlprocessor:
 * <pre>
 * sqlprocessor sqlProcessor =
 *   new sqlprocessor( user.getDefaultSource(), "select id from foo where name = |name| and state = |state|" )
 *   {
 *     protected void process( ResultSet resultSet )
 *     {
 *       processId( resultSet.getString( "id" ) );
 *     }
 *   };
 * sqlProcessor.set( "name", "bar" );
 * sqlProcessor.set( "state", "paid" );
 * sqlProcessor.execute();;
 * </pre>

 * @author Leslie Hensley
 */
public class SQLProcessor
{
  /**
   * @param description       the description is included in the messages of exceptions and
   *                          log messages generated by this class
   * @param sqlText           the text of the sql that will executed. A word surrounded by '#'
   *                          in the string indicates a substitution variable, and a word
   *                          surrounded by '|' indicates a parameter variables.  Parameter
   *                          variables can be used anywhere a '?' can be used in the JDBC API.
   *                          Substitution parameters can be used anywhere in the string but
   *                          are less efficient than parameter variables.
   */
  public SQLProcessor(String description, String sqlText)
  {
    this.rawSQL = sqlText;
    this.taggedSQL = new TaggedSQL(sqlText);
    this.description = description;
    setBean(singletonIterator(new Object()));
  }

  /**
   * @param sqlText           the text of the sql that will executed. A word surrounded by '#'
   *                          in the string indicates a substitution variable, and a word
   *                          surrounded by '|' indicates a parameter variables.  Parameter
   *                          variables can be used anywhere a '?' can be used in the JDBC API.
   *                          Substitution parameters can be used anywhere in the string but
   *                          are less efficient than parameter variables.
   */
  public SQLProcessor(String sqlText)
  {
    this("<No description>", sqlText);
  }

  /**
   * Sets the value of a substitution variable or a parameter variable in the
   * string that was passed to the constructor.  Note that in the case of a
   * conflict in the setting of a parameter variable via this method and
   * <code>setBean</code> this method takes precedence.
   *
   * @ param key      the word that was between '#'s or '|'s in the sqlText
   * @ param value    what variable will be replaced with
   */
  public void set(String key, Object value)
  {
    if (taggedSQL.isParameterKey(key))
    {
      parameterValues.put(key, value);
    }
    else
    {
      taggedSQL.setSubstitution(key, value);
    }
  }

  public void setBigDecimal(String key, BigDecimal decimal, int scale, int roundingMode)
  {
    BigDecimal scaledDecimal = null;

    if (decimal != null)
    {
      scaledDecimal = decimal.setScale(scale, roundingMode);
      set(key, scaledDecimal);
    }
    else
    {
      setNull(key, Types.DECIMAL);
    }
  }

  public boolean hasKey(String key)
  {
    return taggedSQL.isKey(key);
  }

  public void setNull(String key, int type)
  {
    parameterValues.put(key, new SQLNull(type));
  }

  /**
   * A convenience method that wraps <code>value</value> in an <code>Integer</code>
   * and calls the base set method.
   */
  public void set(String key, int value)
  {
    set(key, new Integer(value));
  }

  /**
   * A convenience method that wraps <code>value</value> in an <code>Character</code>
   * and calls the base set method.
   */
  public void set(String key, char value)
  {
    set(key, new String(new char[]{value}));
  }

  /**
   * A convenience method that wraps <code>value</value> in a <code>Double</code>
   * and calls the base set method.
   */
  public void set(String key, double value)
  {
    set(key, new Double(value));
  }

  /**
   * Convenience method to set a possibly null value without having to check if the value is null.
   * @param key Key to set
   * @param value
   * @param sqlType SQL type used for a call to setNull if the value is null.
   */
  public void setNullable(String key, Object value, int sqlType)
  {
    if (value != null)
    {
      set(key, value);
    }
    else
    {
      setNull(key, sqlType);
    }
  }

  /**
   * Maps accessors in the form of <code>getX</code> on <code>bean</code> to
   * parameter variables.  For example if <code>bean</code> has a method
   * named <code>getName</code> the equivilent of
   * <code>set("name", bean.getName())</code> will be performed.
   *
   * @param bean a object with methods of the form <code>getX</code>
   */
  public void setBean(Object bean)
  {
    this.beanIterator = singletonIterator(bean);
  }

  private Iterator singletonIterator(Object bean)
  {
    List list = new ArrayList(1);
    list.add(bean);
    return list.iterator();
  }

  /**
   * Iterates over the bean objects in beanIterator and executes the query
   * once for each item in the iterator.  Note that if <code>setUp</code>
   * is overridden then the return value from <code>setUp</code> takes
   * precedence when the determination is made how many times to execute
   * the query.
   *
   * @param beanIterator
   */
  public void setBean(Iterator beanIterator)
  {
    this.beanIterator = beanIterator;
  }

  /**
   * Tests if results were returned from the query.
   *
   * @return true if at least one row is returned from the query, otherwise
   *  false
   */
  public boolean resultsExist()
  {
    return results;
  }

  /**
   * For when only a single value is needed as the result of a query
   *
   * @return the first column of the last row returned by the query
   */
  public Object getSingleResult()
  {
    return result;
  }

  /**
   * A convenience method that test rhs for equality with the first column
   * of the last row returned by the query
   *
   * @return false if no rows are returned from the query or if the first
   *  column returned from the query is not <code>.equals</code>
   */
  public boolean isSingleResultEqual(Object rhs)
  {
    return resultsExist() && rhs.equals(getSingleResult());
  }

  /**
   * Should be overriden to process the results of queries.  Note that the
   * result set is iterated over by this class, so the <code>next</code> and <code>close</code>
   * methods should never be called on <code>resultSet</code>
   *
   * This method is called if a ResultSet exists, otherwise another
   * process method is called.
   *
   * @see #process(int rowsUpdated)
   * @see #process(int rowsUpdated, java.math.BigInteger insertedId)
   */
  protected void process(ResultSet resultSet) throws SQLException
  {
    result = resultSet.getObject(1);
  }

  /** Should be overridden to process the results of insertions.
   *
   * This method is called if no ResultSet or insertion id was
   * available during processing
   *
   * @see #process(java.sql.ResultSet resultSet)
   * @see #process(int rowsUpdated, java.math.BigInteger insertedId)
   */
  protected void process(int rowsUpdated) throws SQLException
  {
  }

  /** Should be overridden to process the results of insertions.
   *
   * This method is called if there are no resultsets, and an
   * insertion id was available during processing.
   *
   * @see #process(int rowsUpdated)
   * @see #process(java.sql.ResultSet resultSet)

   */
  protected void process(int rowsUpdated, BigInteger insertedId) throws SQLException
  {
  }

  /**
   * Should be overriden if sql needs to be executed more than one time and
   * finer grain control is needed than that provided by <code>setBean</code>.
   * True should be returned as long as the sql should be executed.
   * For example:
   * <pre>
   * final iterator = idList.iterator();
   * sqlprocessor sqlProcessor =
   *   new sqlprocessor( user.getDefaultSource(), "update foo set state = |state| where id = |id|" )
   *   {
   *     protected boolean setUp()
   *     {
   *       if( iterator.hasNext() )
   *       {
   *         Integer id = (Integer)iterator.next();
   *         sqlProcessor.set( "id", id );
   *         sqlProcessor.set( "state", doSomethingComplex(id) );
   *         return true;
   *       }
   *       else
   *       {
   *         return false;
   *       }
   *     }
   *   };
   * sqlProcessor.execute();;
   * </pre>
   */
  protected boolean setUp()
  {
    setupOverridden = false;
    return true;
  }

  /**
   * Should be used if a transaction is needed across multiple interactions
   * with the database.
   */
  public int execute(final Connection connection) throws SQLSystemException
  {
    return execute(new ConnectionSource()
    {
      public Connection getConnection()
      {
        return connection;
      }

      public void returnConnection(Connection c)
      {
      }
    });
  }

  /**
   * Runs the update, insert or query that was specified in the constructor.
   *
   * @param connectionSource  the ConnectionSource for the database that the sql will act on
   */
  public int execute(ConnectionSource connectionSource) throws SQLSystemException
  {
    int rowsUpdated = 0;
    setupOverridden = true;

    bean = EMPTYBEAN;

    result = null;
    Connection connection = connectionSource.getConnection();
    PreparedStatement preparedStatement = null;

    ResultSet resultSet = null;
    try
    {
      preparedStatement = connection.prepareStatement(taggedSQL.getPreparedString());

      while (nextBean())
      {
        prepareStatement(preparedStatement);


        logStatement();

        if (taggedSQL.isQuery())
        {
          resultSet = preparedStatement.executeQuery();

          if (resultSet != null)
          {
            RestrictedResultSet restrictedResultSet = new RestrictedResultSet(resultSet);
            while (resultSet.next())
            {
              results = true;
              process(restrictedResultSet);
            }
          }
        }
        else
        {
          int rowsUpdatedHere = preparedStatement.executeUpdate();
          if (taggedSQL.isInsert())
          {
            checkForInsertedId(connection, rowsUpdatedHere);
          }
          else
          {
            process(rowsUpdatedHere);
          }
          rowsUpdated += rowsUpdatedHere;
        }
      }
      return rowsUpdated;
    }
    catch (SQLException e)
    {
      throw new SQLSystemException("SQL Description: " + description + "\n" +
        "SQL: " + getSQLText(), e);
    }
    finally
    {
      closeResultSetandStatement(resultSet, preparedStatement);
      connectionSource.returnConnection(connection);
    }
  }

  private void checkForInsertedId(Connection conn, int rowsUpdated) throws SQLException
  {
    BigInteger id = fetchLastInsertedId(conn);
    if (id != null)
    {
      insertedIds.add(id);
      process(rowsUpdated, id);
    }
    else
    {
      process(rowsUpdated);
    }
  }

  /**
   * Get the id of the last item inserted into the table.
   * If not implemented by a derived class, a null is always
   * returned and no inserted ids are tracked during execution.
   *
   * @see #getInsertedIds()
   * @see #getLastInsertedId()
   *
   */
  protected BigInteger fetchLastInsertedId(Connection conn)
  {
    return null;
  }


  /**
   * Get array of ids that were inserted during this sqlprocessor's
   * execution. An empty array is returned if no inserted ids were
   * encountered during processing.
   *
   * @see #fetchLastInsertedId(java.sql.Connection))
   * @see #getLastInsertedId()
   *
   */
  public BigInteger[] getInsertedIds()
  {
    return (BigInteger[]) insertedIds.toArray(new BigInteger[insertedIds.size()]);
  }

  /**
   * Get last id that was inserted during this sqlprocessor's
   * execution. Null is returned if no inserted ids were
   * encountered during processing.
   *
   * @see #fetchLastInsertedId(java.sql.Connection))
   * @see #getInsertedIds()
   *
   */
  public BigInteger getLastInsertedId()
  {
    BigInteger last = null;
    if (getInsertedIds().length > 0)
    {
      last = getInsertedIds()[getInsertedIds().length - 1];
    }

    return last;
  }

  /**
   * Get last id's long value representation. If no results
   * were encountered during the sqlprocessor's execution
   * then a -1 is returned.
   */
  public long getLastInsertedIdValue()
  {
    long lastVal = -1;
    BigInteger last = getLastInsertedId();
    if (last != null)
    {
      lastVal = last.longValue();
    }
    return lastVal;
  }

  private void prepareStatement(PreparedStatement preparedStatement) throws SQLException
  {
    Iterator iterator = taggedSQL.getParameterKeys();
    while (iterator.hasNext())
    {
      String key = (String) iterator.next();
      Object value = getValue(key);

      if (value == null)
      {
        throw new IllegalArgumentException("The parameter |" + key + "| was not set\n" +
          "SQL Description: " + description + "\n" +
          "SQL: " + rawSQL);
      }

      for (Iterator i = taggedSQL.getParameterIndices(key).iterator(); i.hasNext();)
      {
        int idx = ((Integer) i.next()).intValue();
        if (value instanceof SQLNull)
        {
          preparedStatement.setNull(idx, ((SQLNull) value).type);
        }
        else
        {
          preparedStatement.setObject(idx, value);
        }
      }
    }
  }


  protected boolean isEmptyBean()
  {
    return this.bean instanceof EmptyBean;
  }

  protected Object currentBean()
  {
    return this.bean;
  }

  protected void setCurrentBean(Object bean)
  {
    this.bean = bean;
  }

  protected boolean nextBean()
  {
    Iterator beanIt = getBeanIterator();

    if (beanIt.hasNext())
    {
      setCurrentBean(beanIt.next());
      return setUp();
    }
    else
    {
      return setUp() && setupOverridden;
    }
  }

  protected Object getValue(String key)
  {
    Object value = parameterValues.get(key);
    if (value == null)
    {
      String attemptedMethod = createGetterNameFromKey(key);

      try
      {
        Method method = null;
        try
        {
          method = bean.getClass().getMethod(attemptedMethod, null);
          value = method.invoke(bean, null);
        }
        catch (NoSuchMethodException e)
        {
          logger.warning("method not found{" + attemptedMethod + "}");
        }
        if (value == null)
        {
          value = beanToNullType.get(key);
        }
        if (value == null && method != null)
        {
          Class ret = method.getReturnType();
          if (ret != null)
          {
            value = convertClassToNullType(ret);
          }
        }
      }
      catch (Exception e)
      {
        logger.log(Level.SEVERE, "bean invocation exception for method{" + attemptedMethod + "}", e);
        throw new IllegalArgumentException("The parameter |" + key + "| was not set\n" +
          "SQL Description: " + description + "\n" +
          "SQL: " + rawSQL);
      }
    }
    return value;
  }

  protected Object convertClassToNullType(Class ret)
  {
    return classToNullType.get(ret.toString());
  }

  protected String createGetterNameFromKey(String key)
  {
    String attemptedMethod = "get" + key.substring(0, 1).toUpperCase() + key.substring(1);
    return attemptedMethod;
  }

  private Object getValueForLogging(String key)
  {
    Object value = null;
    try
    {
      value = getValue(key);
    }

    catch (IllegalArgumentException e)
    {
      value = "!SET{" + key + "}!";
    }

    return value;
  }

  private String getSQLText()
  {
    StringBuffer sqlText = new StringBuffer(taggedSQL.getPreparedStringForLogging());
    StringBuffer output = new StringBuffer(sqlText.length());
    int parameterIndex = 1;
    for (int i = 0; i < sqlText.length(); i++)
    {
      if (sqlText.charAt(i) == '?')
      {
        output.append(prettyParameter(getValueForLogging(taggedSQL.getParameterKey(parameterIndex++))));
      }
      else
      {
        output.append(sqlText.charAt(i));
      }
    }
    return output.toString();
  }

  private void logStatement()
  {
    if (logger.isLoggable(Level.INFO))
    {
      logger.fine(prettyPrint());
    }
  }

  public String prettyPrint()
  {
    return description + ": " + getSQLText();
  }

  private String prettyParameter(Object value)
  {
    if (!(value instanceof Number))
    {
      return "'" + value + "'";
    }
    else
    {
      return value.toString();
    }
  }

  /**
   * If you just want to use the tagged sql syntax and pretty printing power of the sqlprocessor,
   * Use this method instead of executes
   */
  public PreparedStatement getPreparedStatement(ConnectionSource connectionSource) throws SQLException
  {
    return getPreparedStatement(connectionSource.getConnection());
  }

  /**
   * If you just want to use the tagged sql syntax and pretty printing power of the sqlprocessor,
   * Use this method instead of executes
   */
  public PreparedStatement getPreparedStatement(Connection connection) throws SQLException
  {
    PreparedStatement preparedStatement = connection.prepareStatement(taggedSQL.getPreparedString());
    prepareStatement(preparedStatement);
    logStatement();

    return preparedStatement;
  }


  private void closeResultSetandStatement(ResultSet rs, Statement stmt)
  {
    try
    {
      if (rs != null)
      {
        rs.close();
      }
      if (stmt != null)
      {
        stmt.close();
      }
    }
    catch (java.sql.SQLException ignore)
    {
      logger.log(Level.WARNING, "SQLException in cleaning up", ignore);
    }
  }

  protected static class SQLNull
  {
    private int type;

    SQLNull(int type)
    {
      this.type = type;
    }

    public int getType()
    {
      return type;
    }

    public String toString()
    {
      return "<null>";
    }
  }

  protected Iterator getBeanIterator()
  {
    return beanIterator;
  }

  protected Object getParameterValue(String key)
  {
    return parameterValues.get(key);
  }

  protected boolean hasParameterKey(String key)
  {
    return parameterValues.containsKey(key);
  }

  protected String getDescription()
  {
    return description;
  }

  protected String getRawSQL()
  {
    return rawSQL;
  }

  public void setNullType(String[] params, int type)
  {
    for (int i = 0; i < params.length; i++)
    {
      setNullType(params[i], type);
    }
  }

  public void setNullType(String key, int type)
  {
    beanToNullType.put(key, new SQLNull(type));
  }

  public void setDefaultNullType(Class theClass, int type)
  {
    classToNullType.put(theClass.toString(), new SQLNull(type));
  }

  private Logger logger = Logger.global;
  private List insertedIds = new LinkedList();
  protected TaggedSQL taggedSQL;
  private String rawSQL;
  private Map parameterValues = new HashMap();
  private Object bean = EMPTYBEAN;
  private Iterator beanIterator;
  private Object result;
  private String description;
  private boolean setupOverridden = true;
  private boolean results;

  private Map beanToNullType = new HashMap();
  private Map classToNullType = new HashMap();

  private static class EmptyBean extends Object
  {
  };
  protected static final EmptyBean EMPTYBEAN = new EmptyBean();

}